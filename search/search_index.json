{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"Building Systems.Solving Problems. <p>     I am a Software Engineer and Open Source contributor specializing in Kubernetes internals and cloud-native technologies.      I design high-performance systems for vulnerability scanning, automated SBOM (Software Bill of Materials) generation, and scalable distributed architectures.      Currently, I am focused on engineering resilient tools to optimize cloud-native security and enhance Kubernetes controllers.   </p> View Work About Me Blog"},{"location":"404/","title":"404","text":"404 <p>Looks like this page took a wrong redirect. \ud83d\udc7b</p> <p>Maybe our homepage or blog has what you're looking for.</p>"},{"location":"about/","title":"About","text":"Avinesh Tripathi      Software Engineer \u2022 Cloud &amp; Security           \ud83d\udccd Based in India             Email      |        LinkedIn      |      GitHub"},{"location":"about/#experience","title":"Experience","text":""},{"location":"about/#software-engineer-sentinelone","title":"Software Engineer | SentinelOne","text":"<p>Oct 2024 \u2013 Present | Hybrid</p> <ul> <li>Built a container image scanning package with layer-by-layer analysis and SBOM generation, leveraging caching to cut costs by 40% and accelerate scans by 30%.</li> <li>Engineered an on-premises scanning solution allowing customers to analyze images securely in their own environment.</li> <li>Implemented user-facing GraphQL endpoints for a proxy service, improving query performance by 30%.</li> <li>Improved execution speed of internal container image scanner pipeline by 80%.</li> <li>Refactored legacy codebase boosting automated test coverage from 10% to 75%.</li> <li>Designed a state management system for 1000+ private registries tracking millions of container images.</li> </ul>"},{"location":"about/#associate-software-engineer-sentinelone","title":"Associate Software Engineer | SentinelOne","text":"<p>June 2024 \u2013 Sept 2024</p> <ul> <li>Developed private container registry inventory to list all container images along with SBOMs and vulnerabilities.</li> <li>Developed an auto-remediation feature reducing manual intervention by 60%.</li> <li>Participated in development of generic Kubernetes onboarding flow and scaling.</li> </ul>"},{"location":"about/#engineering-intern-sentinelone","title":"Engineering Intern | SentinelOne","text":"<p>Feb 2024 \u2013 May 2024</p> <ul> <li>Developed robust packages in Golang and Javascript for data encryption/decryption (100% end-to-end encryption).</li> <li>Codebase restructuring using Golang channels to reduce service downtime.</li> <li>Refactored KSPM feature for stabilization and performance improvements.</li> <li>Developed end-to-end testing in Python.</li> </ul>"},{"location":"about/#open-source-maintainer-komiser","title":"Open Source Maintainer | Komiser","text":"<p>July 2023 \u2013 Jan 2025 | Remote</p> <ul> <li>Implemented strategies resulting in a 200% reduction in resource fetching.</li> <li>Introduced a config syncing feature preventing configuration drift.</li> <li>Designed dependency graph feature leading to 20% faster resolution.</li> <li>Conducted code reviews and mentorship, leading to a 2x increase in contributors.</li> </ul>"},{"location":"about/#projects-achievements","title":"Projects &amp; Achievements","text":""},{"location":"about/#kubernetes-contributor-summit-award","title":"Kubernetes Contributor Summit Award","text":"<p>Received recognition for contributions to the Kubernetes communications team and improving community participation through social media and blogs.</p>"},{"location":"about/#orch-plugin-based-task-executor-in-go","title":"Orch \u2013 Plugin-based Task Executor in Go","text":"<ul> <li>Built a plugin-based task executor in Go supporting dynamic <code>.so</code> plugins.</li> <li>Designed an API-driven task routing system with retry mechanisms.</li> </ul>"},{"location":"about/#sage-agent","title":"Sage \u2013 Agent","text":"<ul> <li>Added a command execution engine to validate Linux command outputs.</li> <li>Developed a self-healing agent to monitor system metrics.</li> </ul>"},{"location":"about/#technical-skills","title":"Technical Skills","text":"Domain Technologies Languages Go, Java, JavaScript (Node.js), Python Cloud &amp; Infra Kubernetes, Docker, AWS, GCP, Helm Databases MySQL, Redis, PostgreSQL, MongoDB, Kafka, RabbitMQ APIs REST, GraphQL, gRPC Tools &amp; Security GitHub Actions, Jenkins, Prometheus, Grafana, SBOM, Vulnerability Scanning"},{"location":"about/#education","title":"Education","text":"<p>Bachelor of Engineering | Adani University Aug 2020 \u2013 May 2024</p>"},{"location":"blog/","title":"Blogs","text":""},{"location":"blog/2026/02/21/the-ghost-in-the-machine-defeating-redirect-ssrf-in-go/","title":"The Ghost in the Machine: Defeating Redirect SSRF in Go","text":"<p>In the world of web security, we often talk about Server-Side Request Forgery (SSRF) as a direct attack: an attacker tells a server to fetch <code>http://localhost:8080</code>, and the server blindly obeys. Most developers now know to check the initial URL to ensure it doesn't point to a private IP.</p> <p>But there is a more subtle, \"ghostly\" version of this attack that relies on the way HTTP clients handle redirects. It\u2019s a fascinating look at how trust can be exploited across different layers of the network stack, and it shows why a simple IP check on the initial URL is rarely enough.</p>","tags":["go","security","ssrf","architecture"]},{"location":"blog/2026/02/21/the-ghost-in-the-machine-defeating-redirect-ssrf-in-go/#the-learning-scenario-the-redirect-trap","title":"The Learning Scenario: The Redirect Trap","text":"<p>In our day to day job as developers, we often deal with external services and APIs where we need to fetch data from a given URL. This could be to get some information about a user, a product, or anything else or in case of a webhook, we might need to send some data to a given URL. The common pattern we follow is: resolve the DNS, check if the IP is private, and if not, go ahead and fetch.</p> <p>The \"Liar's Move\" exploited by attackers works like this:</p> <ol> <li>An attacker provides a URL to a public server they control: <code>https://public-attacker-site.com/proxy</code>.</li> <li>Your server checks the IP. It\u2019s public. Check passed.</li> <li>Your server makes the request.</li> <li>The attacker\u2019s server responds with an HTTP 302 Found and a header: <code>Location: http://192.168.1.1/admin</code>.</li> <li>Your standard HTTP client follows that redirect automatically.</li> <li>Because the safety check only happened on the first URL, the client is redirected into your internal network.</li> </ol>","tags":["go","security","ssrf","architecture"]},{"location":"blog/2026/02/21/the-ghost-in-the-machine-defeating-redirect-ssrf-in-go/#visualizing-the-attack","title":"Visualizing the Attack","text":"<pre><code>sequenceDiagram\n    participant Attacker\n    participant Server as Your Go Server\n    participant Public as Public Malicious Server\n    participant Internal as Internal Resource (192.168.1.1)\n\n    Attacker-&gt;&gt;Server: Fetch metadata for public-attacker-site.com/proxy\n    Server-&gt;&gt;Server: Check IP: It's Public! (Trust established)\n    Server-&gt;&gt;Public: GET /proxy\n    Public--&gt;&gt;Server: 302 Redirect to http://192.168.1.1/admin\n    Note over Server: Standard client follows redirect...\n    Server-&gt;&gt;Internal: GET /admin\n    Internal--&gt;&gt;Server: Sensitive Data\n    Server--&gt;&gt;Attacker: Metadata (containing sensitive data)</code></pre>","tags":["go","security","ssrf","architecture"]},{"location":"blog/2026/02/21/the-ghost-in-the-machine-defeating-redirect-ssrf-in-go/#step-1-seeing-the-vulnerability-the-before-test","title":"Step 1: Seeing the Vulnerability (The \"Before\" Test)","text":"<p>To understand this, let's write a Go test that simulates an attacker. We set up two servers: an \"internal\" server with confidential data, and a \"malicious\" server that redirects our client into it.</p>","tags":["go","security","ssrf","architecture"]},{"location":"blog/2026/02/21/the-ghost-in-the-machine-defeating-redirect-ssrf-in-go/#the-vulnerable-code","title":"The Vulnerable Code","text":"<pre><code>func FetchMetadata(client *http.Client, url string) (*http.Response, error) {\n    return client.Get(url)\n}\n</code></pre>","tags":["go","security","ssrf","architecture"]},{"location":"blog/2026/02/21/the-ghost-in-the-machine-defeating-redirect-ssrf-in-go/#the-test-case","title":"The Test Case","text":"<pre><code>func TestVulnerableClient(t *testing.T) {\n    // 1. An internal server with confidential data\n    internalServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        fmt.Fprintln(w, \"CONFIDENTIAL DATA\")\n    }))\n    defer internalServer.Close()\n\n    // 2. A malicious server that redirects to the internal server\n    maliciousServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        http.Redirect(w, r, internalServer.URL, http.StatusFound)\n    }))\n    defer maliciousServer.Close()\n\n    // 3. A vulnerable client follows the redirect blindly\n    resp, err := FetchMetadata(&amp;http.Client{}, maliciousServer.URL)\n    if err == nil {\n        fmt.Printf(\"Vulnerability Confirmed: Client reached %s\\n\", resp.Request.URL)\n    }\n}\n</code></pre>","tags":["go","security","ssrf","architecture"]},{"location":"blog/2026/02/21/the-ghost-in-the-machine-defeating-redirect-ssrf-in-go/#step-2-hardening-the-application-layer-l7","title":"Step 2: Hardening the Application Layer (L7)","text":"<p>The first fix is to teach our <code>http.Client</code> to be skeptical of redirects. We use the <code>CheckRedirect</code> hook. This function runs before every hop. If the next destination is private, we kill the request.</p> <pre><code>func NewSecureClient() *http.Client {\n    return &amp;http.Client{\n        CheckRedirect: func(req *http.Request, via []*http.Request) error {\n            if len(via) &gt;= 10 {\n                // by default http client follows 10 redirects, we can limit it to prevent infinite loops\n                return errors.New(\"stopped after 10 redirects\")\n            }\n\n            host := req.URL.Hostname()\n            ips, err := net.LookupIP(host)\n            if err != nil {\n                return fmt.Errorf(\"security block: could not lookup IP for %s\", host)\n            }\n\n            for _, ip := range ips {\n                if ip.IsPrivate() || ip.IsLoopback() ||\n                    ip.IsLinkLocalUnicast() || ip.IsLinkLocalMulticast() ||\n                    ip.IsUnspecified() {\n                    return fmt.Errorf(\"security block: redirect to private IP %s\", ip)\n                }\n            }\n            return nil\n        },\n    }\n}\n</code></pre> <p><code>CheckRedirect</code> is our first line of defense at the application logic layer (L7). It prevents the client from blindly following a trail that leads into your private VPC.</p>","tags":["go","security","ssrf","architecture"]},{"location":"blog/2026/02/21/the-ghost-in-the-machine-defeating-redirect-ssrf-in-go/#step-3-the-ultimate-safety-net-l4","title":"Step 3: The Ultimate Safety Net (L4)","text":"<p>Wait! There is still a catch. What if an attacker uses DNS Rebinding?</p> <p>This is a classic Time-of-Check to Time-of-Use (TOCTOU) vulnerability. The attacker makes a domain resolve to a public IP for your <code>CheckRedirect</code> logic (Time-of-Check). Then, they quickly swaps to point to a private IP (like <code>127.0.0.1</code>) right as the HTTP client tries to establish the actual TCP connection (Time-of-Use).</p> <p>To prevent this, we add a check at the Network Layer (L4). By using the <code>Control</code> function in a <code>net.Dialer</code>, we can inspect the IP address at the exact moment the socket is being created, but before the connection is established. This is our \"physical\" barrier.</p> <pre><code>func HardenedTransport() *http.Transport {\n    return &amp;http.Transport{\n        DialContext: (&amp;net.Dialer{\n            // Control is the \"last mile\" check. It's called after the IP is resolved\n            // but before the connection is actually made.\n            Control: func(network, address string, c syscall.RawConn) error {\n                host, _, err := net.SplitHostPort(address)\n                if err != nil {\n                    return err\n                }\n                ip := net.ParseIP(host)\n                if ip != nil &amp;&amp; (ip.IsPrivate() || ip.IsLoopback() ||\n                    ip.IsLinkLocalUnicast() || ip.IsLinkLocalMulticast() ||\n                    ip.IsUnspecified()) {\n                    return errors.New(\"L4 Block: Private IP detected at connection time\")\n                }\n                return nil\n            },\n        }).DialContext,\n    }\n}\n</code></pre> <p>This L4 check is the most robust defense because it doesn't care about DNS records or redirect headers. It only cares about the destination IP on the wire.</p>","tags":["go","security","ssrf","architecture"]},{"location":"blog/2026/02/21/the-ghost-in-the-machine-defeating-redirect-ssrf-in-go/#step-4-the-final-after-test","title":"Step 4: The Final \"After\" Test","text":"<p>Now, let's combine both L7 and L4 protections into a \"Hardened Client\" and run our test again.</p>","tags":["go","security","ssrf","architecture"]},{"location":"blog/2026/02/21/the-ghost-in-the-machine-defeating-redirect-ssrf-in-go/#the-hardened-client","title":"The Hardened Client","text":"<pre><code>func HardenedClient() *http.Client {\n    client := NewSecureClient() // L7 Protection\n    client.Transport = HardenedTransport() // L4 Protection\n    return client\n}\n</code></pre>","tags":["go","security","ssrf","architecture"]},{"location":"blog/2026/02/21/the-ghost-in-the-machine-defeating-redirect-ssrf-in-go/#the-success-test","title":"The Success Test","text":"<pre><code>func TestSecureClient(t *testing.T) {\n    // Same setup: internal + malicious servers\n    internalServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        fmt.Fprintln(w, \"CONFIDENTIAL DATA\")\n    }))\n    defer internalServer.Close()\n\n    maliciousServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        http.Redirect(w, r, internalServer.URL, http.StatusFound)\n    }))\n    defer maliciousServer.Close()\n\n    client := HardenedClient()\n    _, err := FetchMetadata(client, maliciousServer.URL)\n\n    if err != nil {\n        fmt.Printf(\"Success: The hardened client blocked the redirect!\\n\")\n        fmt.Printf(\"Error: %v\\n\", err)\n    } else {\n        t.Error(\"Failure: The client still followed the redirect.\")\n    }\n}\n</code></pre>","tags":["go","security","ssrf","architecture"]},{"location":"blog/2026/02/21/the-ghost-in-the-machine-defeating-redirect-ssrf-in-go/#summary","title":"Summary","text":"<p>By using a layered approach to security, we see that SSRF isn't just about the first URL you receive. It\u2019s about every hop the client takes afterward.</p> <ul> <li>CheckRedirect (L7) stops the logic of following a trail.</li> <li>Dialer Control (L4) acts as a physical barrier to the network, preventing DNS rebinding tricks.</li> </ul> <p>When you stack these layers together, your Go applications become significantly more resilient to the \"ghosts\" in the redirect chain.</p>","tags":["go","security","ssrf","architecture"]},{"location":"blog/2026/02/21/the-ghost-in-the-machine-defeating-redirect-ssrf-in-go/#try-it-yourself","title":"Try it Yourself","text":"<p>You can run the full simulation (both vulnerable and hardened scenarios) directly in the Go Playground:</p> <p>\ud83d\udc49 Go Playground - Redirect SSRF Lab</p> <p>Views are my own. Security is a moving target. Always stay curious and skeptical.</p> <p>If you're interested in learning more about Kubernetes security, check out my other posts on the topic.</p>","tags":["go","security","ssrf","architecture"]},{"location":"blog/2026/02/12/adding-metrics--tls-to-a-kubernetes-controller---the-kustomize-way/","title":"Adding Metrics &amp; TLS to a Kubernetes Controller - The Kustomize Way","text":"<p>I recently worked on adding metrics and TLS support to the Node Readiness Controller, a kubernetes-sigs project I contribute to. What I thought would be a straightforward config change turned into a rabbit hole of Kustomize components, cert-manager wiring, and Makefile gymnastics. Here's what happened.</p>","tags":["kustomize","prometheus","tls"]},{"location":"blog/2026/02/12/adding-metrics--tls-to-a-kubernetes-controller---the-kustomize-way/#some-context","title":"Some context","text":"<p>If you haven't heard of it, Node Readiness Controller is a Kubernetes controller that manages node taints based on readiness rules. The simplest way to think about it:</p> <p>You have a node that isn't ready to accept traffic. You want workloads to land on it only when certain node conditions are met. This controller lets you define those rules.</p> <p>The project has a documentation site with examples if you want to try it out.</p> <p>After the first release, it was pretty bare bones. Then the questions started showing up: \"Can I scrape Prometheus metrics from this?\" and \"Is the traffic secured with TLS?\"</p> <p>The Kubernetes ecosystem has great support for all of this, and since the project uses kubebuilder, I figured it would be straightforward which it was in terms of boilerplate setup (everything we needed is part of the kubebuilder setup; we just need to follow the book. Spoiler: it wasn't as simple as I expected. This post is about the config changes I had to make to get everything working.</p> <p>Fair warning: This was my first time setting up metrics and TLS for a controller from scratch. I'm not claiming this is the best way to do it; it's what I figured out by reading docs, trying things, and breaking stuff. If you know better approaches, I'm all ears. PRs, issues, DMs, whatever works \ud83d\ude4f</p>","tags":["kustomize","prometheus","tls"]},{"location":"blog/2026/02/12/adding-metrics--tls-to-a-kubernetes-controller---the-kustomize-way/#what-i-was-trying-to-achieve","title":"What I was trying to achieve","text":"<p>I needed to support these deployment profiles from a single codebase:</p> Profile Metrics TLS Webhook Bare-bones \u274c \u274c \u274c Metrics (HTTP) \u2705 <code>:8080</code> \u274c \u274c Metrics + TLS \u2705 <code>:8443</code> \u2705 cert-manager \u274c <p>One hard rule: the source <code>config/</code> directory should never be mutated at build time. Everything had to be additive and reversible. And of course, unlike Helm, you can't do <code>if ... else ...</code> in Kustomize (which turned out to be one of the biggest headaches).</p>","tags":["kustomize","prometheus","tls"]},{"location":"blog/2026/02/12/adding-metrics--tls-to-a-kubernetes-controller---the-kustomize-way/#kustomize-components-to-the-rescue","title":"Kustomize Components to the rescue","text":"<p>I landed on Kustomize Components (<code>kind: Component</code>) which is used by a lot of projects in the ecosystem. Unlike overlays that produce standalone variants, components get applied into whichever base includes them. Each feature became its own self-contained component:</p> <pre><code>config/\n\u251c\u2500\u2500 default/              # Base: namespace, prefix, RBAC, manager\n\u2502   \u2514\u2500\u2500 kustomization.yaml\n\u251c\u2500\u2500 prometheus/           # Component: metrics service (HTTP)\n\u2502   \u251c\u2500\u2500 kustomization.yaml\n\u2502   \u251c\u2500\u2500 metrics_service.yaml\n\u2502   \u251c\u2500\u2500 manager_prometheus_metrics.yaml\n\u2502   \u2514\u2500\u2500 tls/              # Sub-component: upgrade to HTTPS\n\u2502       \u251c\u2500\u2500 kustomization.yaml\n\u2502       \u251c\u2500\u2500 certificate.yaml\n\u2502       \u251c\u2500\u2500 cert_metrics_manager_patch.yaml\n\u2502       \u251c\u2500\u2500 manager_prometheus_metrics_tls.yaml\n\u2502       \u2514\u2500\u2500 metrics_service_tls_patch.yaml\n\u251c\u2500\u2500 certmanager/          # Component: self-signed Issuer\n\u2502   \u251c\u2500\u2500 kustomization.yaml\n\u2502   \u251c\u2500\u2500 certificate.yaml\n\u2502   \u2514\u2500\u2500 kustomizeconfig.yaml\n\u2514\u2500\u2500 webhook/              # Component: ValidatingWebhookConfiguration\n    \u251c\u2500\u2500 kustomization.yaml\n    \u251c\u2500\u2500 manifests.yaml\n    \u251c\u2500\u2500 service.yaml\n    \u251c\u2500\u2500 certificate.yaml\n    \u251c\u2500\u2500 webhook_patch.yaml\n    \u251c\u2500\u2500 manager_webhook_patch.yaml\n    \u2514\u2500\u2500 kustomizeconfig.yaml\n</code></pre> <p>Notice how HTTP and HTTPS metrics have their own directories under <code>prometheus/</code>. That's because the patches for the manager deployment are different. HTTP just sets <code>--metrics-bind-address=:8080</code>, while HTTPS needs the TLS flags, cert volume mounts, and a different port. We were also adding a ServiceMonitor as part of the HTTPS config at one point, but that got removed later (story for another blog maybe).</p> <p>It's fun, you get everything in the Kubernetes docs \ud83d\ude04</p>","tags":["kustomize","prometheus","tls"]},{"location":"blog/2026/02/12/adding-metrics--tls-to-a-kubernetes-controller---the-kustomize-way/#the-build-pipeline-feature-flags-makefile","title":"The build pipeline: feature flags + Makefile","text":"<p>To add components to a base you normally run <code>kustomize edit add component &lt;path&gt;</code>, but that modifies the kustomization file in place. Since I didn't want to touch the source tree, I went with a temporary build directory approach.</p>","tags":["kustomize","prometheus","tls"]},{"location":"blog/2026/02/12/adding-metrics--tls-to-a-kubernetes-controller---the-kustomize-way/#copy-patch-build-clean-up","title":"Copy, patch, build, clean up","text":"<pre><code>BUILD_DIR := $(ROOT_DIR)/bin/build\n\nbuild-manifests-temp: manifests $(KUSTOMIZE)\n    @mkdir -p $(BUILD_DIR)\n    @rm -rf $(BUILD_DIR)/config\n    @cp -r config $(BUILD_DIR)/\n    # ... conditionally add components ...\n    @$(KUSTOMIZE) build $(BUILD_DIR)/config/default &gt; $(BUILD_DIR)/manifests.yaml\n    @rm -rf $(BUILD_DIR)/config\n</code></pre> <p>Copy <code>config/</code> to a temp dir, run <code>kustomize edit</code> there, build, and throw it away. The source stays clean.</p>","tags":["kustomize","prometheus","tls"]},{"location":"blog/2026/02/12/adding-metrics--tls-to-a-kubernetes-controller---the-kustomize-way/#three-flags-control-everything","title":"Three flags control everything","text":"<pre><code>ENABLE_METRICS ?= false\nENABLE_TLS     ?= false\nENABLE_WEBHOOK ?= false\n</code></pre> <p>The Makefile uses shell <code>if</code> blocks to compose the right set of components:</p> <pre><code># TLS: Add certmanager component for certificates\n@if [ \"$(ENABLE_TLS)\" = \"true\" ]; then \\\n    cd $(BUILD_DIR)/config/default &amp;&amp; $(KUSTOMIZE) edit add component ../certmanager; \\\nfi\n\n# Webhook: Requires TLS for certificates\n@if [ \"$(ENABLE_WEBHOOK)\" = \"true\" ]; then \\\n    if [ \"$(ENABLE_TLS)\" != \"true\" ]; then \\\n        echo \"ERROR: ENABLE_WEBHOOK=true requires ENABLE_TLS=true\"; exit 1; \\\n    fi; \\\n    cd $(BUILD_DIR)/config/default &amp;&amp; $(KUSTOMIZE) edit add component ../webhook; \\\nfi\n\n# Metrics: Add prometheus, with TLS config if enabled\n@if [ \"$(ENABLE_METRICS)\" = \"true\" ]; then \\\n    cd $(BUILD_DIR)/config/default &amp;&amp; $(KUSTOMIZE) edit add component ../prometheus; \\\n    if [ \"$(ENABLE_TLS)\" = \"true\" ]; then \\\n        cd $(BUILD_DIR)/config/default &amp;&amp; \\\n            $(KUSTOMIZE) edit add component ../prometheus/tls; \\\n    else \\\n        cd $(BUILD_DIR)/config/prometheus &amp;&amp; \\\n            $(KUSTOMIZE) edit add patch --path manager_prometheus_metrics.yaml \\\n            --kind Deployment --name controller-manager; \\\n    fi; \\\nfi\n</code></pre> <p>Webhooks require TLS, so you get a clear error if you forget. Is this the best approach? Probably not. But it works, and I'm happy to change it if someone has a cleaner idea.</p> <p>There are convenience targets too so you don't have to remember the flags:</p> <pre><code>deploy-with-metrics:             ENABLE_METRICS=true\ndeploy-with-metrics-and-tls:     ENABLE_METRICS=true ENABLE_TLS=true\ndeploy-with-webhook:             ENABLE_TLS=true ENABLE_WEBHOOK=true\n</code></pre> <p>One <code>make deploy-with-webhook</code> and the whole stack comes up.</p>","tags":["kustomize","prometheus","tls"]},{"location":"blog/2026/02/12/adding-metrics--tls-to-a-kubernetes-controller---the-kustomize-way/#how-the-tls-part-works","title":"How the TLS part works","text":"<p>Here's the end-to-end flow when metrics are served over HTTPS:</p> <pre><code>sequenceDiagram\n    participant CM as cert-manager\n    participant K8s as Kubernetes\n    participant Pod as Controller Pod\n    participant Prom as Prometheus\n    CM-&gt;&gt;K8s: Create self-signed Issuer\n    CM-&gt;&gt;K8s: Issue Certificate \u2192 Secret (metrics-server-cert)\n    K8s-&gt;&gt;Pod: Mount secret as volume at /tmp/k8s-metrics-server/metrics-certs\n    Pod-&gt;&gt;Pod: Start with --metrics-bind-address=:8443 --metrics-secure --metrics-cert-dir=...\n    Prom-&gt;&gt;Pod: Scrape https://:8443/metrics</code></pre> <p>On the Go side, controller-runtime made this surprisingly easy. Three flags is all it takes:</p> <pre><code>flag.StringVar(&amp;metricsAddr, \"metrics-bind-address\", \"0\", \"...\")\nflag.BoolVar(&amp;metricsSecure, \"metrics-secure\", false, \"...\")\nflag.StringVar(&amp;metricsCertDir, \"metrics-cert-dir\", \"\", \"...\")\n\nmetricsServerOptions := metricsserver.Options{\n    BindAddress:   metricsAddr,\n    CertDir:       metricsCertDir,\n    SecureServing: metricsSecure,\n    FilterProvider: func() ... {\n        if metricsSecure {\n            return filters.WithAuthenticationAndAuthorization\n        }\n        return nil\n    }(),\n}\n</code></pre> <p>When <code>--metrics-secure</code> set, the metrics server serves over HTTPS and enforces Kubernetes auth on every scrape request via the filter provider. The <code>WithAuthenticationAndAuthorization</code> filter only kicks in when TLS is on; you can read more about it in the controller-runtime docs.</p> <p>We missed the actual metrics code here too; it's simple but important and you can read it here</p>","tags":["kustomize","prometheus","tls"]},{"location":"blog/2026/02/12/adding-metrics--tls-to-a-kubernetes-controller---the-kustomize-way/#things-that-broke-along-the-way","title":"Things that broke along the way \ud83d\udc1b","text":"","tags":["kustomize","prometheus","tls"]},{"location":"blog/2026/02/12/adding-metrics--tls-to-a-kubernetes-controller---the-kustomize-way/#port-number-confusion","title":"Port number confusion","text":"<p>Two modes mean two ports:</p> <ul> <li> <p>HTTP \u2192 <code>:8080</code></p> </li> <li> <p>HTTPS \u2192 <code>:8443</code></p> </li> </ul> <p>The default <code>metrics-bind-address</code> is <code>\"0\"</code> disabled. I needed the Kustomize patches to set the right port depending on TLS. Ended up with two separate patches:</p> <ul> <li> <p><code>manager_prometheus_metrics.yaml</code> \u2192 sets <code>--metrics-bind-address=:8080</code></p> </li> <li> <p><code>manager_prometheus_metrics_tls.yaml</code> \u2192 sets <code>--metrics-bind-address=:8443</code> plus <code>--metrics-secure</code> and <code>--metrics-cert-dir</code></p> </li> </ul> <p>The service also needed patching. The TLS patch deletes the HTTP port and adds HTTPS:</p> <pre><code>spec:\n  ports:\n  - name: http\n    $patch: delete\n  - name: https\n    port: 8443\n    targetPort: 8443\n</code></pre> <p>Straightforward once you figure it out, but I definitely stared at this for a while before it clicked.</p>","tags":["kustomize","prometheus","tls"]},{"location":"blog/2026/02/12/adding-metrics--tls-to-a-kubernetes-controller---the-kustomize-way/#makes-entering-directory-messages-breaking-kubectl","title":"Make's \"Entering directory\" messages breaking kubectl","text":"<p>This one was fun. During e2e tests, the output of <code>make build-manifests-temp</code> gets piped into <code>kubectl apply</code>. It turns out Make prints <code>make: Entering directory '...'</code> when you use <code>--directory</code>, and kubectl tries to parse that as YAML. Obviously it fails.</p> <p>The fix was simple: prefix recipe lines with <code>@</code> to suppress echoing, and use <code>--no-print-directory</code> for sub-makes. But finding why <code>kubectl apply</code> was choking took longer than I'd like to admit.</p>","tags":["kustomize","prometheus","tls"]},{"location":"blog/2026/02/12/adding-metrics--tls-to-a-kubernetes-controller---the-kustomize-way/#the-certificate-worked-for-prometheus-but-didnt-for-webhooks","title":"The certificate worked for Prometheus but didn't for webhooks??","text":"<p>While this was not part of this initial effort, later when I was setting up webhooks, something went wrong. This was the error:</p> <p>Error from server (InternalError): error when creating \"config/samples/duplicate_taint.yaml\": Internal error occurred: failed calling webhook \"vnodereadinessrule.kb.io\": failed to call webhook: Post \"https://nrr-webhook-service.nrr-system.svc:443/validate-readiness-node-x-k8s-io-v1alpha1-nodereadinessrule?timeout=10s\": tls: failed to verify certificate: x509: certificate is valid for webhook-service.system.svc, webhook-service.system.svc.cluster.local, not nrr-webhook-service.nrr-system.svc</p> <p>We moved to using it <code>replacement</code> to populate the <code>dnsName</code> field of the certificates, and it turned out the replacement was not appending the <code>nrr-</code> prefix if the certificate was not part of the base dir. Having the certificate in the base dir added a dependency for certificates of both webhook and metrics to be present, which is not the case every time. Hence, we moved to the classic hardcoding approach.</p> <p>Not a supporter of this for sure, but hey, it works if you hardcode things for a specific component.</p>","tags":["kustomize","prometheus","tls"]},{"location":"blog/2026/02/12/adding-metrics--tls-to-a-kubernetes-controller---the-kustomize-way/#what-id-do-differently","title":"What I'd do differently","text":"<ol> <li> <p>Validate kustomize build output in CI earlier. I added <code>kustomize build</code> checks late. A CI step that builds all four profiles and validates the YAML would have caught issues much faster.</p> </li> <li> <p>Helm might be better for complex composition. Kustomize Components worked for 3 toggleable features. If I had 10+, I'd probably reach for Helm's templating. There's actually an issue open to add Helm support to the project.</p> </li> </ol>","tags":["kustomize","prometheus","tls"]},{"location":"blog/2026/02/12/adding-metrics--tls-to-a-kubernetes-controller---the-kustomize-way/#takeaways","title":"Takeaways","text":"<ul> <li> <p>Kustomize Components are underrated. They're basically feature flags for YAML. Great for optional stuff that layers on top of a base.</p> </li> <li> <p>Don't mutate source config at build time. Copy to temp, patch there, build, clean up. Keeps your git history sane.</p> </li> <li> <p>controller-runtime makes the Go side of TLS easy. Point it at a cert directory, set <code>SecureServing: true</code>, done. The hard part is getting the certs to the right place via Kustomize and cert-manager.</p> </li> </ul>","tags":["kustomize","prometheus","tls"]},{"location":"blog/2026/02/12/adding-metrics--tls-to-a-kubernetes-controller---the-kustomize-way/#the-pr-that-started-all-of-this","title":"The PR that started all of this","text":"<p>Honestly, one of the most fun parts was the PR discussion. What started as \"just add metrics support\" turned into a deep conversation about Kustomize architecture, TLS best practices, cert-manager edge cases, and Makefile ergonomics. If you enjoy watching how things get built in open source, the full discussion is here: PR #79 \u2014 Enable metrics manifests.</p> <p>A lot of the patterns I described in this post came directly from reviewer feedback on that PR. Open source at its best.</p>","tags":["kustomize","prometheus","tls"]},{"location":"blog/2026/02/12/adding-metrics--tls-to-a-kubernetes-controller---the-kustomize-way/#give-it-a-spin","title":"Give it a spin","text":"<pre><code># Basic deploy (no metrics, no TLS)\nmake deploy\n\n# Metrics over HTTP\nmake deploy-with-metrics\n\n# Metrics over HTTPS + cert-manager\nmake deploy-with-metrics-and-tls\n</code></pre> <p>Requires some pre-installed CRDs for now!</p> <p>The source is at kubernetes-sigs/node-readiness-controller. Like I said, this was a first for me, and I'm sure there's room to do things better. If you've done something similar or have ideas, I'd love to hear about it.</p> <p>Views are my own. Shaped by a lot of trial, error, and some really helpful code reviews. Shoutout to the amazing maintainers</p>","tags":["kustomize","prometheus","tls"]},{"location":"projects/","title":"Projects","text":"<p>Check out some of the things I've built and contributed to.</p> Node Readiness Controller <p>A Kubernetes controller that manages node taints based on readiness rules. Active contributor \u2014 added metrics, TLS, webhook support, and DRA integration.</p> Go Kubernetes Open Source Komiser <p>Cloud cost &amp; asset management tool. As a maintainer, I achieved 200% reduction in resource fetching, introduced config syncing, and designed the dependency graph feature.</p> Go Cloud Open Source Orch \u2014 Plugin-based Task Executor <p>A plugin-based task executor in Go supporting dynamic .so plugins with an API-driven task routing system and retry mechanisms.</p> Go Architecture Sage \u2014 Self-Healing Agent <p>A command execution engine that validates Linux command outputs and monitors system metrics with self-healing capabilities.</p> Go Observability"},{"location":"blog/archive/2026/","title":"2026","text":""}]}